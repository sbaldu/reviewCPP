# Comparison of assembly code for runtime and compile-time implementations
The strength of metaprogramming in C++ is that it moves calculation from the execution to the
compilation phase. Since the code only needs to be compiled one, the resulting runtime
execution is much faster.  
A simple way to observe that no computation is in fact done at runtime, thus understanding
better way the code is faster, is to look at the assembly code generated by the compiler.  

If we look at the assembly code from the basic implementation we see that the main portion of
the program looks like this:
```assembly
_Z9factoriali:
.LFB1983:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	subq	$24, %rsp
	.cfi_offset 3, -24
	movl	%edi, -20(%rbp)
	cmpl	$0, -20(%rbp)
	jne	.L2
	movl	$1, %eax
	jmp	.L3
.L2:
	movl	-20(%rbp), %eax
	movslq	%eax, %rbx
	movl	-20(%rbp), %eax
	subl	$1, %eax
	movl	%eax, %edi
	call	_Z9factoriali
	imulq	%rbx, %rax
.L3:
	movq	-8(%rbp), %rbx
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
```
where it can be seen that the code is executing recursively the same function by calling the
`.L2` and `.L3` functions. This is the code that is executed at runtime.
If we now look at the meta implementation:
```assembly
main:
.LFB1983:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movabsq	$2432902008176640000, %rax
	movq	%rax, %rsi
	movl	$_ZSt4cout, %edi
	call	_ZNSolsEy
	movl	$10, %esi
	movq	%rax, %rdi
	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
```
Now the value, which in our case is `20!`, is calculated at compile time and the result is
directly moved inside the `rax` register and printed. This is the code that is executed at
runtime.
